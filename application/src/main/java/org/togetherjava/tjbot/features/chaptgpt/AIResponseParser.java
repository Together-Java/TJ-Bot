package org.togetherjava.tjbot.features.chaptgpt;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class AIResponseParser {

    private AIResponseParser() {}

    private static final Logger logger = LoggerFactory.getLogger(AIResponseParser.class);
    private static final int RESPONSE_LENGTH_LIMIT = 2_000;

    /**
     * Parses the response generated by AI. If response is longer than
     * {@value RESPONSE_LENGTH_LIMIT}, then breaks apart the response into suitable lengths for
     * Discords API.
     * 
     * @param response The response from the AI which we want to send over Discord.
     * @return An optional array potentially holding the original response split up into shorter
     *         than {@value RESPONSE_LENGTH_LIMIT} length pieces.
     */
    public static Optional<String[]> parse(String response) {
        String[] aiResponses;
        if (response.length() > RESPONSE_LENGTH_LIMIT) {
            logger.warn(
                    "Response from AI was longer than allowed limit. "
                            + "The answer was cut up to max {} characters length messages",
                    RESPONSE_LENGTH_LIMIT);
            aiResponses = breakupAiResponse(response);
        } else {
            aiResponses = new String[] {response};
        }

        return Optional.of(aiResponses);
    }

    private static String[] breakupAiResponse(String response) {
        List<String> responseChunks = new ArrayList<>();
        String[] chunksOnMarks = response.split("```");

        for (int i = 0; i < chunksOnMarks.length; i++) {
            // Likely to be the first occurrence in the split array if the response started with
            // code. Don't filter zero length chunks out since code relies on 'i' to indicate when
            // code blocks must be re-entered; If zero length chunks were removed then order of
            // chunks lose property of text -> code -> text -> code -> ...
            if (chunksOnMarks[i].length() == 0) {
                continue;
            }

            String chunk = chunksOnMarks[i];
            String[] chunks = new String[2];
            if (chunk.length() > RESPONSE_LENGTH_LIMIT) {
                int midpointNewline = chunk.lastIndexOf("\n", chunk.length() / 2);
                chunks[0] = chunk.substring(0, midpointNewline);
                chunks[1] = chunk.substring(midpointNewline);
            } else {
                chunks[0] = chunk;
            }

            // Given the splitting on ```, the odd numbered entries need to have code marks
            // restored.
            if (i % 2 != 0) {
                for (int j = 0; j < chunks.length; j++) {
                    if (Objects.nonNull(chunks[j])) {
                        chunks[j] = "```".concat(chunks[j]).concat("```");
                    }
                }
            }

            List<String> list = Arrays.stream(chunks).filter(Objects::nonNull).toList();
            responseChunks.addAll(list);
        } // end of for loop.

        return responseChunks.toArray(new String[0]);
    }
}
